<?php

/**
 * @file
 * Allow webforms to integrate with Salesforce via th Salesforce Suite module.
 */

include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'salesforce_webforms') . '/' . 'salesforce_webforms.maps.inc';

/**
 * Implements hook_menu().
 */
function salesforce_webforms_menu() {
  $items = array();

  $items['node/%webform_menu/webform/salesforce'] = array(
    'title' => 'Salesforce',
    'page callback' => 'salesforce_webforms_manage',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'weight' => 4,
    'type' => MENU_LOCAL_TASK,
  );

  $items['node/%webform_menu/webform/salesforce/add/%'] = array(
    'title' => 'Add object mapping',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_manage_map', 1, 'add', 5),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/webform/salesforce/edit/%/%salesforce_webforms_map'] = array(
    'title' => 'Edit map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_manage_map', 1, 'edit', 5, 6),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/webform/salesforce/delete/%salesforce_webforms_map'] = array(
    'title' => 'Delete map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_delete_rule', 5),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/webform/salesforce/picklists/%salesforce_object'] = array(
    'title' => 'Picklists for object',
    'page callback' => 'salesforce_webforms_picklists',
    'page arguments' => array(5),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'path' => drupal_get_path('module', 'salesforce_webforms'),
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/submission/%webform_menu_submission/sf'] = array(
    'title' => 'Resubmit to Salesforce',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_resubmit', 1, 3),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Loads object map from menu parameter.
 *
 * @param int $mapid
 *   The ID of the map to load.
 *
 * @return array
 *   The map data.
 */
function salesforce_webforms_map_load($mapid) {
  return salesforce_webforms_get_map($mapid);
}

/**
 * Implements hook_theme().
 */
function salesforce_webforms_theme() {
  return array(
    'salesforce_webforms_manage_add_map' => array(
      'variables' => array(
        'nid' => NULL,
      ),
    ),
    'salesforce_webforms_manage_overview' => array(
      'variables' => array(
        'maps' => NULL,
        'node' => NULL,
      ),
    ),
  );
}

/**
 * Returns HTML for an 'add map' list.
 *
 * @param array $variables
 *   An associative array containing:
 *   - nid: The node ID.
 *
 * @ingroup themeable
 */
function theme_salesforce_webforms_manage_add_map(array $variables) {
  $nid = $variables['nid'];
  $output = '';
  $objects = salesforce_webforms_get_objects();

  if ($objects) {
    $output = '<h3>' . t('Add an object mapping') . '</h3>';
    $output .= '<dl>';
    foreach ($objects as $object_name => $object_info) {
      $item = '';
      $url = 'node/' . $nid . '/webform/salesforce/add/' . $object_name;
      $item = '<dt>' . l($object_info['label'], $url, array('query' => drupal_get_destination())) . '</dt>';
      $item .= '<dd>';
      if ($object_info['fields']) {
        $item .= "<ul>";
        foreach ($object_info['fields'] as $field) {
          $item .= '<li>' . $field['label'] . '</li>';
        }
        $item .= '</ul>';
      }
      $item .= '</dd>';
      $output .= $item;
    }
    $output .= '</dl>';
  }
  return $output;
}

/**
 * Returns all defined Salesforce objects.
 *
 * @param bool $use_cache
 *   Determines if the cached data is acceptable (TRUE) or if the cache
 *   should be bypassed and updated (FALSE).
 *
 * @return array
 *   An associative array of Salesforce objects, keyed by the internal
 *   Salesforce name of the object.
 */
function salesforce_webforms_get_objects($use_cache = TRUE) {
  $sobjects = _salesforce_webforms_fetch("sobjects", $use_cache);
  $return = array();

  foreach ($sobjects['sobjects'] as $data) {
    $return[$data['name']] = $data;
  }
  return $return;
}

/**
 * Gets the list of Saelforce objects as an array of options.
 *
 * @return array
 *   An associative array appropriate for use as an 'options' element.
 */
function salesforce_webforms_get_objects_selection() {
  $selections = array();
  $objs = salesforce_webforms_get_objects();
  if ($objs) {
    foreach ($objs as $info) {
      $selections[$info['name']] = $info['label'];
    }
  }
  return $selections;
}

/**
 * Gets the Salesforce suite object and verified connectivity.
 *
 * @return object
 *   The Salesforce object used for communicating with Salesforce.
 */
function salesforce_webforms_get_sfapi() {
  $sf = &drupal_static(__FUNCTION__);

  if (!isset($sf)) {
    $sf = salesforce_get_api();
    $sf->isAuthorized();
  }

  return $sf;
}

/**
 * Gets the fields for a given object.
 *
 * @param string $obj
 *   The internal Salesforce name of the object.
 * @param bool $use_cache
 *   Determines if the cache should be used (TRUE) or bypassed and
 *   updated (FALSE).
 *
 * @return array
 *   An associative array of fields, keyed by the field name. The data of
 *   each field is an array of attributes as defined by Salesforce.
 */
function salesforce_webforms_get_object_fields($obj, $use_cache = TRUE) {
  $sf = salesforce_webforms_get_sfapi();
  $sobject = $sf->objectDescribe($obj, !$use_cache);
  $return = array();

  foreach ($sobject['fields'] as $field) {
    $return[$field['name']] = $field;
  }
  return $return;
}

/**
 * Implements hook_webform_component_info().
 */
function salesforce_webforms_webform_component_info() {
  $components = array();

  $components['sf_picklist'] = array(
    'label' => t('Salesforce picklist'),
    'description' => t('Select list driven by a Salesforce picklist'),
    'features' => array(
      // Includes an analysis callback.
      'analysis' => TRUE,
      // Include in CSV.
      'csv' => TRUE,
      // Allows default values?
      'default_value' => FALSE,
      // Allows a description field?
      'description' => TRUE,
      // Valid as field in emails?
      'email' => TRUE,
      // Valid as an email FROM or TO?
      'email_address' => FALSE,
      // Valid as an email name?
      'email_name' => FALSE,
      // Can this be set to required?
      'required' => TRUE,
      // Supports the 'title' attribute?
      'title' => FALSE,
      // Has a title which can be toggled on/off?
      'title_display' => TRUE,
      // Can title be displayed inline?
      'title_inline' => TRUE,
      // Can other fields conditionally display based on this field?
      'conditional' => TRUE,
      // Can this be a group container?
      'group' => FALSE,
      // Can this be used for SPAM analysis?
      'spam_analysis' => FALSE,
      // Saves attachements?
      'attachment' => FALSE,
      // Supports a range of values?
      'views_range' => FALSE,
    ),

    // Conditional comparison type.
    'conditional_type' => 'select',

    'file' => 'salesforce_webforms.picklist.inc',
  );

  return $components;
}

/**
 * Saves a mapping.
 *
 * @param array $values
 *   An associative array containing:
 *   - object: String identifying the Salesforce object.
 *   - action: One of:
 *     - add.
 *     - edit.
 *   - map_id: Int ID of the map to be operated upon.
 *   - map_fields: Associative array of fields and values.
 */
function salesforce_webforms_map_save(array $values) {
  // Save map data.
  $values['sf_object'] = $values['object'];

  if ($values['action'] == 'add') {
    drupal_write_record('salesforce_webforms_map', $values);
  }
  elseif ($values['action'] == 'edit') {
    drupal_write_record('salesforce_webforms_map', $values, 'mapid');
  }
  else {
    // Invalid operation. Return.
    return;
  }
  $mapid = $values['mapid'];
  if ($mapid) {
    // Delete the old version of the fields, if any.
    db_delete('salesforce_webforms_field')
      ->condition('mapid', $mapid)
      ->execute();

    if (array_filter($values['map_fields'])) {
      salesforce_webforms_save_fields($mapid, $values['map_fields']);
    }
  }
}

/**
 * Save the individual field mappings of a map.
 *
 * @param int $mapid
 *   The ID of the map being saved.
 * @param array $fields
 *   An associative array of fields and values, keyed by field name, containing:
 *   - target: String identifying target value.
 *   - key_field: Boolean indicating if this is a key field.
 *   - picklist: (optional) String to override target.
 */
function salesforce_webforms_save_fields($mapid, array $fields) {
  $i = 1;
  foreach ($fields as $fname => $values) {
    // Only process if we are given source data.
    if ($values['picklist']) {
      $values['target'] = $values['picklist'];
    }

    if ($values['target']) {
      db_insert('salesforce_webforms_field')
        ->fields(
          array(
            'mapid' => $mapid,
            'sf_fieldname' => $fname,
            'source_data' => filter_xss($values['target']),
            'is_keyfield' => $values['keyfield'][1],
            'displayorder' => $i++,
          )
        )
        ->execute();
    }
  }
}

/**
 * Implements hook_webform_submission_insert().
 */
function salesforce_webforms_webform_submission_insert($node, $sub, $update = FALSE) {
  // See if we have any maps for this node.
  $maps = salesforce_webforms_get_node_maps($node->nid);
  if (!$maps || count($maps) == 0) {
    return;
  }
  else {
    if ($update) {
      // Get any existing keys.
      $existing_keys = salesforce_webforms_get_submission_keys($sub->sid);
    }
    foreach ($maps as $map) {
      // Fields to use as keys.
      $keyfields = array();
      $fields = array();

      // Get the data and parse out the tokens.
      $object = $map['sf_object'];
      $mapname = $map['mapname'];

      foreach ($map['fields'] as $field) {
        $target = $field['sf_fieldname'];
        $source = $field['source_data'];
        $key = $field['keyfield'];

        $filtered_source = _webform_filter_values($source, $node, $sub);
        if ($key) {
          // We have a key field - try update first.
          $keyfields[$target] = $filtered_source;
        }

        $fields[$target] = $filtered_source;
      }

      // See if we are always creating new, or trying to update existing.
      $target_id = $existing_keys[$mapname];
      if (!$target_id && count($keyfields) > 0) {
        // Try to find the ID.
        $sql = "SELECT Id FROM $object WHERE ";
        $union = "";
        foreach ($keyfields as $field => $val) {
          $sql .= "$union$field = '$val'";
          $union = " AND ";
        }
        $res = _salesforce_webforms_fetch("query?q=" . urlencode($sql));
        if (count($res['records']) > 0) {
          $target_id = $res['records'][0]['Id'];
        }
      }

      if ($target_id) {
        // Do an update.
        $res = salesforce_webforms_update_object($object, $target_id, $fields);
      }
      else {
        $res = salesforce_webforms_create_object($object, $fields);
        $target_id = $res['id'];
      }

      db_insert('salesforce_webforms_key')
        ->fields(
          array(
            'sid' => $sub->sid,
            'mapname' => $map['mapname'],
            'sfid' => $target_id,
          )
        )
        ->execute();
    }
  }
}

/**
 * Implements hook_webform_submission_delete().
 */
function salesforce_webforms_webform_submission_delete($node, $sub) {
  db_delete('salesforce_webforms_key')
    ->condition('sid', $sub->sid)
    ->execute();
}

/**
 * Implements hook_webform_submission_actions().
 */
function salesforce_webforms_webform_submission_actions($node, $sub) {
  $actions = array();

  // See if we have any mappings.
  $map = salesforce_webforms_get_node_maps($node->nid);
  if (!$map) {
    return $actions;
  }

  $actions['sf'] = array(
    'title' => t('Resend to Salesforce'),
    'href' => 'node/' . $node->nid . '/submission/' . $sub->sid . '/sf',
    'query' => drupal_get_destination(),
  );

  return $actions;
}

/**
 * Implements hook_token_info_alter().
 */
function salesforce_webforms_token_info_alter(&$data) {
  $data['tokens']['submission']['salesforce'] = array(
    'name' => t('Salesforce ID'),
    'description' => t('The unique ID of the Salesforce object associated with a webform mapping. Replace the "?" with the name of the mapping'),
    'dynamic' => TRUE,
  );
}

/**
 * Implements hook_tokens().
 */
function salesforce_webforms_tokens($type, $tokens, array $data = array(), $options = array()) {
  $replacements = array();

  if ($type == 'submission' && !empty($data['webform-submission'])) {
    $sub = $data['webform-submission'];
    $node = $data['node'] ? $data['node'] : node_load($sub->nid);
    $nid = $node->nid;

    if ($sf_tokens = token_find_with_prefix($tokens, 'salesforce')) {
      // We need map data. Load it up.
      $keys = salesforce_webforms_get_submission_keys($sub->sid);
      foreach ($sf_tokens as $name => $original) {
        $replacements[$original] = $keys[$name];
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_form_alter().
 */
function salesforce_webforms_form_alter(&$form, &$state, $fid) {
  // See if this is a webform with our components.
  $needs_update = FALSE;
  if (isset($state['webform']['component_tree']['children'])) {
    foreach ($state['webform']['component_tree']['children'] as $component) {
      if ($component['type'] == 'sf_picklist') {
        $needs_update = TRUE;
      }
    }
  }

  if ($needs_update) {
    $form['#attached']['js'][] = drupal_get_path('module', 'salesforce_webforms') . '/js/salesforce.js';
  }
}

/**
 * Loads data from Salesforce, optionally thorugh a cache.
 *
 * @param string $url
 *   The Salesforce URL used to fetch the data.
 * @param bool $use_cache
 *   A flag indicating whether to use the cached data (TRUE) or bypass and
 *   update the cache (FALSE).
 *
 * @return array
 *   The Salesforce response data.
 */
function _salesforce_webforms_fetch($url, $use_cache = TRUE) {
  // Do we need to switch languages for the connection?
  $lang = salesforce_webforms_language_prefix();

  $cachename = "salesforce_webforms_" . $lang . md5($url);
  if ($use_cache) {
    $cached = cache_get($cachename);
    if ($cached && $cached->expire >= time() && !empty($cached->data)) {
      return $cached->data;
    }
  }

  // Not in cache, or we're ignore the cache data.
  // Do we need to switch languages()?
  if ($lang) {
    salesforce_webforms_set_sf_language(salesforce_webforms_language_code());
  }

  $sf = salesforce_webforms_get_sfapi();
  try {
    $data = $sf->apiCall($url);
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
  }

  // Switch back to English if needed.
  if ($lang) {
    salesforce_webforms_set_sf_language("en_US");
  }

  // Update the cache with the data.
  cache_set($cachename, $data, "cache", time() + 60 * 60 * 12);

  return $data;
}

/**
 * Implements hook_cron().
 */
function salesforce_webforms_cron() {
  // The list of possible picklists is big
  // Refresh the cache on a regular basis.
  watchdog("salesforce_webforms", "Initiate cache refresh");
  $objlist = salesforce_webforms_get_objects(FALSE);
  $queue = DrupalQueue::get('salesforce_webforms');
  $queue->createItem(array_keys($objlist));
}

/**
 * Implements hook_cron_queue_info().
 */
function salesforce_webforms_cron_queue_info() {
  $queues['salesforce_webforms'] = array(
    'worker callback' => 'salesforce_webforms_queue_obj',
    'time' => 120,
  );

  return $queues;
}

/**
 * Refreshes the cache data for info on a given object or list of objects.
 *
 * @param string|string[] $objlist
 *   An object name, or an array of names, to be refreshed.
 */
function salesforce_webforms_queue_obj($objlist) {
  if (!is_array($objlist)) {
    $objlist = array($objlist);
  }

  foreach ($objlist as $obj) {
    watchdog("salesforce_webforms", "Cache refresh of %obj", array('%obj' => $obj));
    salesforce_webforms_get_object_fields($obj, FALSE);
  }
}

/**
 * Updates an existing Salesforce object.
 *
 * @param string $object
 *   The Salesforce internal name of the object type to be updated.
 * @param string $id
 *   The Salesforce ID of the object to be updated.
 * @param array $fields
 *   The fields and corresponding values to be stored.
 *
 * @return array
 *   The Salesforce response as an array.
 */
function salesforce_webforms_update_object($object, $id, array $fields) {
  $sf = salesforce_webforms_get_sfapi();
  $res = $sf->objectUpdate($object, 'id', $id, $fields);

  return $res;
}

/**
 * Creates a new Salesforce object.
 *
 * @param string $object
 *   The Salesforce internal name of the object type to be creatd.
 * @param array $fields
 *   The fields and corresponding values to be stored.
 *
 * @return array
 *   The Salesforce response as an array.
 */
function salesforce_webforms_create_object($object, array $fields) {
  $sf = salesforce_webforms_get_sfapi();
  $res = $sf->objectCreate($object, $fields);

  return $res;
}

/**
 * Get the path prefix for the specified language, or the current context.
 *
 * Used to ensure that cached objects are associated with the correct
 * language.
 *
 * @param string $lang
 *   The language to look up. If not specified, then the language of the
 *   currently loaded page will be used.
 *
 * @return string
 *   The prefix code to use for the specified or current language.
 */
function salesforce_webforms_language_prefix($lang = NULL) {
  if (isset($lang)) {
    $list = language_list('language');
    $prefix = $list[$lang]->prefix;
  }
  else {
    $prefix = $GLOBALS['language']->prefix;
  }
  if ($prefix != "") {
    $prefix .= "_";
  }
  return $prefix;
}

/**
 * Sets the language attribute of the salesforce API user.
 *
 * This is a workaround, since it's not possible within SalesForce
 * to specify the language to return for picklists. To get around
 * that, we temporarily set the active language of the user
 * authenticated to SalesForce to that language. We then set it back
 * when we're done.
 *
 * @param string $lang
 *   The language code to make active.
 */
function salesforce_webforms_set_sf_langauge($lang) {
  $id = variable_get("fema_faq_sf_user_id", "");
  $fields = array(
    'LanguageLocaleKey' => $lang,
  );
  fema_faq_update_object("User", $id, $fields);
}

/**
 * Gets the Salesforce language code for the given Drupal language code.
 *
 * In most instances, these two values are the same. However, for English,
 * Drupal uses 'en' while Salesforce expects 'en_US'.
 *
 * @param string $language
 *   The language to query. If not specified, the language of the current
 *   page is used.
 *
 * @return string
 *   The Salesforce language code corresponding to the Drupal language code.
 */
function salesforce_webforms_langauge_code($language = NULL) {
  if (!isset($language)) {
    $language = $GLOBALS['language']->language;
  }
  if ($language == 'en') {
    $language = 'en_US';
  }

  return $language;
}
